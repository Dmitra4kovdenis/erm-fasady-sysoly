
## Структура страниц

Пока все страницы статичные

Все страницы находятся на `src/app/`

Название паки со страницей = путь до страницы в адресной строке. 
NextJS считает страницей все, что находится в папке `app` и называется `page.tsx`.
Папки до `page.tsx` он считает путем


`src/app/(private)` - здесь находятся приватные страницы (не доступные без авторизации)


## Структура страницы

### `page.tsx` - точка входа в страницу. 

Серверный компонент. В нем происходят действия:
1. Создаются методы для получения данных с БД
2. Получаются параметры из адресной строки для загрузки данных
3. Загружаются данные из БД
4. Возвращается клиентский компонент, данные передаются через props

Пример

```typescript jsx
import { prisma } from "@/prisma-helpers/prisma";
import { ClientCustomers } from "@/app/(private)/customers/client";

// создаем метод для получения данных с БД
const getCustomers = async () => {
  return prisma.customer.findMany();
};

// создаем тип этих данных для переиспользования внутри
export type CustomerList = Awaited<ReturnType<typeof getCustomers>>;

// сам комонент
async function Page() {
    // получаем данные через созданный метод
  const customers = await getCustomers();

  // вовращаем клиентский компонент
  return <ClientCustomers customers={customers} />;
}

// обязательно экспорт по умолчанию
export default Page;
```

### `client.tsx` - клиентский компонент

Задача - получить данные с props и отобразить клиентский интерфейс

Обязательно помечается сверху `"use client"`

### `actions.ts` - список экшенов

Экшен - метод, который должен выполнятся на сервере (загрузка данных в БД, запрос)

### `components` - папка с компонентами страницы

Локальные компоненты, которые нужны только для этой страницы 
(например, некоторые вынесенные блоки, модалки и тп)


## Работа с параметрами

Как получать параметры, можно почитать в доке. 

Тип получаемых параметров по умолчанию `string | string[] | undefined`.
Поэтому для полноценной стабильной работы и типизации её нужно валидировать через zod (https://zod.dev/)

Так мы можем решить проблемы
1. Привести к типу `number` определенные параметры
2. Обработать ошибки, если пользователь каким то образом добавил в адресную строку неожиданные для нас параметры
3. Безопасно типизировать объект адресной строки

Пример

```typescript jsx
import { SearchParams } from "@/types";
import { prisma } from "@/prisma-helpers/prisma";
import { z } from "zod";

const getWorker = async (workerId: number) => {
  return prisma.worker.findMany();
};

export type Workers = Awaited<ReturnType<typeof getWorkers>>;

// определяем модель для валидации
const Model = z.object({
    // объявляем workerId, которую приводим к типу число, и задаем минимальное значение как 0
  workerId: coerce.number().min(0),
});

// с пропсов получаем searchParams
async function WorkByPeriod({ searchParams }: { searchParams: SearchParams }) {
  // получаем параметры из него
    const params = await searchParams;

    // получаем отвалидируемый объект
  const result = Model.safeParse(params);

  // если валидация успешна
  if (result.success) {
      // в параметр отправляем уже поле из отвалидированного объекта
    const worker = await getWorker(result.data.workerId)
    return (
        <ClientComponent worker={worker} />
    );
  }

  // если валидация не успешна, можем вернуть компонент-заглушку под такой кейс
  return <ClientComponentWithoutWorker workers={workers} />;
}

export default WorkByPeriod;
```

